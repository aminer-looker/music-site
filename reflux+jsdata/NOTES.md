
### Observations

  * Stores really can't expose their own copy of any given object because it would allow a "back channel" for controllers and such to change state without creating an action. At best, they would return a proxy object whose "setter" methods don't permit such actions.  At the very least, they need to return a copy which, when modified, wouldn't alter the internal state of anything in the store.
  * Reflux provides a way to define a store as a role in the pattern, but no content inside it. It is left completely up to the implementor to decide how it should be implemented. For example, if you want your store to be backed by a RESTful service, you'll need to provide your own way of doing so with some other code (e.g., JSData, jQuery's `ajax` method, or even plain `XMLHTTPRequest`).
  * Actions are used for *any* alteration to a store.  This can both be things like incorporating user actions into shared data store or requesting data be loaded from the server.  The common practice in this latter case seems to be to fire off a "load" action and then listen for the matching event downstream.
  * How well does this copy model work when you have deeply nested structures, especially large ones?
  * Determining exactly what gets returned from the stores is problematic. If you return the JSData object directly, then people will be able to mutate it without going through the proper channels (i.e., submitting an action, etc.).  If you don't return the JSData object, you can't take advantage of it's ability to have computed methods and the like to make ease the life of the presentation layer, nor can you take advantage of its automatically formed relationships.  The other alternative is to return some third object which is richer than the raw JSON data, but isn't the actual JSData object. This object could wrap a JSData object and expose an interface which is both "safe" in that it will only mutate state in the proper way, and "rich" in that it can contain extra logic needed by the view layer.
  * Should controllers be allowed to have state? You could imagine setting things up so that there are special-purpose stores which manage state for all the important parts of the screen (e.g., what is the current composer on a composer detail page, which is the selected tab, etc.).  This would seem to make the most sense as it allows the various stores to have dependencies on one another and refresh things as needed.
