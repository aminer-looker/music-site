
### JSData

* You have to jump through some hoops to make sure a `Promise` constructor is attached to the global namespace (i.e., `window` or `global`) before initializing JS-Data.  On the client, `js-data-angular` does this for you, but on the server side, you need to manage it yourself.
* The documentation for the js-data-sql adapter doesn't mention that you can add a a 'database' config setting along with the host/port/user/password.
* The documentation for the `defineResource` method doesn't mention that you can add a 'table' property to a resource definition if your table isn't named the same thing as the resource (e.g., the resource is singular, but the table is plural).
* When defining services for the client, Angular doesn't create the services automatically, so if you register a Resource as part of a service, you'll later need to force those services to be instantiated manually since JSData won't do this for you. Instead, when it attempts to resolve a relation, it will complain of a missing Resource.
* JSData doesn't provide a way to get a count of resources without actually fetching them all and counting the result.  However, using a `<module>.run` method, you can add a function to `DS.defaults` which will then appear on each Resource object.  So, if you add a `count` method to `DS.defaults`, each of your Resource services will have a `count` method along side the `find`, `findAll`, etc.
    * However... when adding such functions, you need to use the adapter directly, so unless what you want to do is possible using the standard js-data Resource methods, you'll need to create adapter-specific versions of your code.
* Adding a `$watch` on a Resource object won't get triggered when its relations are resolved. Instead, you need to set the watch after you've loaded the relations.
* When fetching a collection of Resources, it's not possible to return any meta-data about the collection (e.g., offset, limit, total).  This means you need at least one more request to support paging (i.e., the total).
* The documentation is confusing about what properties you should use when defining relations. You really nee three things:
    * localField: the property name of the fully-instantiated relation (or array). (e.g, `foo`)
    * localKey: the property containing the foreign key on the Resource (e.g., `foo_id`)
    * foreignKey: the key on the target Resource which should match the `localKey` (e.g., `id`)
* The documentation isn't very clear about what properties you can include when calling the `findAll` method when using the SQL adapter. The underlying library is [Knex.js](http://knexjs.org/), and it's documentation lays out the possibilities pretty well.
* It doesn't work to try to `JSON.stringify` resources. You need to add your own `toJSON` method or the equivalent.
* There doesn't appear to be any way to look up a resource constructor once you've created it.  Thus, you need to stash the result of calling `defineResource` somewhere so that your code can use it to access those resources.
* The use of the cache is different between the web and server environments.  In particular, the server, by default, has the cache turned off (to avoid problems with multiple workers). This comes up whenever you perform an operation which implicitly uses a cached version (e.g., `store.save()`).


### Reflux

  * Stores really can't expose their own copy of any given object because it would allow a "back channel" for controllers and such to change state without creating an action. At best, they would return a proxy object whose "setter" methods don't permit such actions.  At the very least, they need to return a copy which, when modified, wouldn't alter the internal state of anything in the store.
  * Reflux provides a way to define a store as a role in the pattern, but no content inside it. It is left completely up to the implementor to decide how it should be implemented. For example, if you want your store to be backed by a RESTful service, you'll need to provide your own way of doing so with some other code (e.g., JSData, jQuery's `ajax` method, or even plain `XMLHTTPRequest`).
  * Actions are used for *any* alteration to a store.  This can both be things like incorporating user actions into shared data store or requesting data be loaded from the server.  The common practice in this latter case seems to be to fire off a "load" action and then listen for the matching event downstream.
  * How well does this copy model work when you have deeply nested structures, especially large ones?
  * Determining exactly what gets returned from the stores is problematic. If you return the JSData object directly, then people will be able to mutate it without going through the proper channels (i.e., submitting an action, etc.).  If you don't return the JSData object, you can't take advantage of it's ability to have computed methods and the like to make ease the life of the presentation layer, nor can you take advantage of its automatically formed relationships.  The other alternative is to return some third object which is richer than the raw JSON data, but isn't the actual JSData object. This object could wrap a JSData object and expose an interface which is both "safe" in that it will only mutate state in the proper way, and "rich" in that it can contain extra logic needed by the view layer.
  * Should controllers be allowed to have state? You could imagine setting things up so that there are special-purpose stores which manage state for all the important parts of the screen (e.g., what is the current composer on a composer detail page, which is the selected tab, etc.).  This would seem to make the most sense as it allows the various stores to have dependencies on one another and refresh things as needed.
  * There are two different kinds of "listening" going on with Flux, and it's a bit easy to mix them up. The first is when a data store is listening to actions.  This can either use the `listenTo` method defined on the store.  This expects either an action function or a store.  Any time either "triggers", the given method will be invoked in the context of the store.  The second kind of listening is what the view layer does with a store. In this case, you invoked the `listen` method passing in the function you'd like called when the store triggers.  This callback is not bound to any particular object, so you'll need to do that yourself if necessary.
  * When controllers listen to stores, they need to wrap the action of the listener in `$scope.$apply` so that bindings get updated properly. Since Reflux doesn't know about Angular, it doesn't do this for you automatically.
